"""autogenerated by genpy from gps_node/GPSFix.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import gps_node.msg
import std_msgs.msg

class GPSFix(genpy.Message):
  _md5sum = "7d80aa63f37a9b7b932b38216fc5314b"
  _type = "gps_node/GPSFix"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """# A more complete GPS fix to supplement sensor_msgs/NavSatFix.
Header header

GPSStatus status

# Latitude (degrees). Positive is north of equator; negative is south.
float64 latitude

# Longitude (degrees). Positive is east of prime meridian, negative west.
float64 longitude

# Altitude (meters). Positive is above reference (e.g., sea level).
float64 altitude

# Direction (degrees from north)
float64 track

# Ground speed (meters/second)
float64 speed

# Vertical speed (meters/second)
float64 climb

# Device orientation (units in degrees)
float64 pitch
float64 roll
float64 dip

# GPS time
float64 time

## Dilution of precision; Xdop<=0 means the value is unknown

# Total (positional-temporal) dilution of precision
float64 gdop

# Positional (3D) dilution of precision
float64 pdop

# Horizontal dilution of precision
float64 hdop

# Vertical dilution of precision
float64 vdop

# Temporal dilution of precision
float64 tdop

## Uncertainty of measurement, 95% confidence

# Spherical position uncertainty (meters) [epe]
float64 err

# Horizontal position uncertainty (meters) [eph]
float64 err_horz

# Vertical position uncertainty (meters) [epv]
float64 err_vert

# Track uncertainty (degrees) [epd]
float64 err_track

# Ground speed uncertainty (meters/second) [eps]
float64 err_speed

# Vertical speed uncertainty (meters/second) [epc]
float64 err_climb

# Temporal uncertainty [ept]
float64 err_time

# Orientation uncertainty (degrees)
float64 err_pitch
float64 err_roll
float64 err_dip

# Position covariance [m^2] defined relative to a tangential plane
# through the reported position. The components are East, North, and
# Up (ENU), in row-major order.

float64[9] position_covariance

uint8 COVARIANCE_TYPE_UNKNOWN = 0
uint8 COVARIANCE_TYPE_APPROXIMATED = 1
uint8 COVARIANCE_TYPE_DIAGONAL_KNOWN = 2
uint8 COVARIANCE_TYPE_KNOWN = 3

uint8 position_covariance_type

string lastRawData
###############################################################################
#=== RMC - Recommended Minimum Navigation Information ===
#
#------------------------------------------------------------------------------
#                                                          12
#        1         2 3       4 5        6  7   8   9    10 11|  13
#        |         | |       | |        |  |   |   |    |  | |   |
# $--RMC,hhmmss.ss,A,llll.ll,a,yyyyy.yy,a,x.x,x.x,xxxx,x.x,a,m,*hh<CR><LF>
#------------------------------------------------------------------------------#
#
#Field Number:
#
#1. UTC Time
string rmc1UTCTime
#2. Status, V=Navigation receiver warning A=Valid
string rmc2STatus
#3. Latitude
string rmc3Latitude
#4. N or S
string rmc4LatNorS
#5. Longitude
string rmc5Longitude
#6. E or W
string rmc6LongEorW
#7. Speed over ground, knots
string rmc7SpeedOverGroundInKnots
#8. Track made good, degrees true
string rmc8TrackMadeGoodDegreeTrue
#9. Date, ddmmyy
string rmc9Date
#10. Magnetic Variation, degrees
string rmc10MagneticVariationDegrees
#11. E or W
string rmc11MagnetEorW
#12. FAA mode indicator (NMEA 2.3 and later)
string rmc12FAAModeIndicator
#13. Checksum
###############################################################################
#                                                      11
#        1         2       3 4        5 6 7  8   9  10 |  12 13  14   15
#        |         |       | |        | | |  |   |   | |   | |   |    |
# $--GGA,hhmmss.ss,llll.ll,a,yyyyy.yy,a,x,xx,x.x,x.x,M,x.x,M,x.x,xxxx*hh<CR><LF>
#------------------------------------------------------------------------------
#
#Field Number:
#1. Universal Time Coordinated (UTC)
string gga1UTC
#2. Latitude
string gga2Latitude
#3. N or S (North or South)
string gga3LatNorS
#4. Longitude
string gga4Longitude
#5. E or W (East or West)
string gga5LongEorW
#6. GPS Quality Indicator,
string gga6GPSQuality
string gga6GPSQualityStatus
#     - 0 - fix not available,
#     - 1 - GPS fix,
#     - 2 - Differential GPS fix
#           (values above 2 are 2.3 features)
#     - 3 = PPS fix
#     - 4 = Real Time Kinematic
#     - 5 = Float RTK
#     - 6 = estimated (dead reckoning)
#     - 7 = Manual input mode
#     - 8 = Simulation mode
#7. Number of satellites in view, 00 - 12
string gga7NumberOfSatellites
#8. Horizontal Dilution of precision (meters)
string gga8HorizontalDilutionOfPrescision
#9. Antenna Altitude above/below mean-sea-level (geoid) (in meters)
string gga9AntennaAltitudeAboveBelowMeanSeaLevel
#10. Units of antenna altitude, meters
string gga10UnitsOfAntennaAltitude_inMeters
#11. Geoidal separation, the difference between the WGS-84 earth
string gga11GeoidalSeparation
#     ellipsoid and mean-sea-level (geoid), "-" means mean-sea-level
#     below ellipsoid
#12. Units of geoidal separation, meters
string gga12UnitsOfGeoidalSeperation
#13. Age of differential GPS data, time in seconds since last SC104
string gga13AgeOfDifferentialGPSData
#     type 1 or 9 update, null field when DGPS is not used
#14. Differential reference station ID, 0000-1023
string gga14DifferentialReferenceStationID
#15. Checksum

###############################################################################
# $--GSA,a,a,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x.x,x.x,x.x*hh<CR><LF>
#------------------------------------------------------------------------------
#
#Field Number:
#
#1. Selection mode: M=Manual, forced to operate in 2D or 3D, A=Automatic, 3D/2D
string gsa1SelectionMode
#2. Mode (1 = no fix, 2 = 2D fix, 3 = 3D fix)
string gsa2Mode
#3. ID of 1st satellite used for fix
string gsa3ID1
#4. ID of 2nd satellite used for fix
string gsa4ID2
#5. ID of 4rd satellite used for fix
string gsa5ID3
#6. ID of 4th satellite used for fix
string gsa6ID4
#7. ID of 5th satellite used for fix
string gsa7ID5
#8. ID of 6th satellite used for fix
string gsa8ID6
#9. ID of 7th satellite used for fix
string gsa9ID7
#10. ID of 8th satellite used for fix
string gsa10ID8
#11. ID of 9th satellite used for fix
string gsa11ID9
#12. ID of 10th satellite used for fix
string gsa12ID10
#13. ID of 11th satellite used for fix
string gsa13ID11
#14. ID of 12th satellite used for fix
string gsa14ID12
#15. PDOP
string gsa15PDOP
#16. HDOP
string gsa16HDOP
#17. VDOP
string gsa17VDOP
#18. Checksum
#
#
#=== GSV - Satellites in view ===
#
#These sentences describe the sky position of a UPS satellite in view.
#Typically they're shipped in a group of 2 or 3.
#
#------------------------------------------------------------------------------
#        1 2 3 4 5 6 7     n
#        | | | | | | |     |
# $--GSV,x,x,x,x,x,x,x,...*hh<CR><LF>
#------------------------------------------------------------------------------#
#
#Field Number:
#
int8 gsvAdet
#1. total number of GSV messages to be transmitted in this group
string gsv1NumberOfGSV
#2. 1-origin number of this GSV message  within current group
string gsv2NumberOfMessage
#3. total number of satellites in view (leading zeros sent)
string gsv3NumberOfStallitesInView
#4. satellite PRN number (leading zeros sent)
string gsv4SatellitePRNNumber
#5. elevation in degrees (00-90) (leading zeros sent)
string gsv5ElevationDegrees
#6. azimuth in degrees to true north (000-359) (leading zeros sent)
string gsv6AzimuthIndegries
#7. SNR in dB (00-99) (leading zeros sent)
string gsv7SRNin_dB
#   more satellite info quadruples like 4-7
string gsv8MoreSatelliteInfoQuadruples
#   n) checksum
#
#Example:
#    $GPGSV,3,1,11,03,03,111,00,04,15,270,00,06,01,010,00,13,06,292,00*74
#    $GPGSV,3,2,11,14,25,170,00,16,57,208,39,18,67,296,40,19,40,246,00*74
#    $GPGSV,3,3,11,22,42,067,42,24,14,311,43,27,05,244,00,,,,*4D
#
#Some GPS receivers may emit more than 12 quadruples (more than three
#GPGSV sentences), even though NMEA-0813 doesn't allow this.  (The
#extras might be WAAS satellites, for example.) Receivers may also
#report quads for satellites they aren't tracking, in which case the
#SNR field will be null; we don't know whether this is formally allowed
#or not.
#
#
#
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: gps_node/GPSStatus
Header header

# Satellites used in solution
uint16 satellites_used # Number of satellites
int32[] satellite_used_prn # PRN identifiers

# Satellites visible
uint16 satellites_visible
int32[] satellite_visible_prn # PRN identifiers
int32[] satellite_visible_z # Elevation of satellites
int32[] satellite_visible_azimuth # Azimuth of satellites
int32[] satellite_visible_snr # Signal-to-noise ratios (dB)

# Measurement status
int16 STATUS_NO_FIX=-1   # Unable to fix position
int16 STATUS_FIX=0       # Normal fix
int16 STATUS_SBAS_FIX=1  # Fixed using a satellite-based augmentation system
int16 STATUS_GBAS_FIX=2  #          or a ground-based augmentation system
int16 STATUS_DGPS_FIX=18 # Fixed with DGPS
int16 STATUS_WAAS_FIX=33 # Fixed with WAAS
int16 status

uint16 SOURCE_NONE=0 # No information is available
uint16 SOURCE_GPS=1 # Using standard GPS location [only valid for position_source]
uint16 SOURCE_POINTS=2 # Motion/orientation fix is derived from successive points
uint16 SOURCE_DOPPLER=4 # Motion is derived using the Doppler effect
uint16 SOURCE_ALTIMETER=8 # Using an altimeter
uint16 SOURCE_MAGNETIC=16 # Using magnetic sensors
uint16 SOURCE_GYRO=32 # Using gyroscopes
uint16 SOURCE_ACCEL=64 # Using accelerometers

uint16 motion_source # Source for speed, climb and track
uint16 orientation_source # Source for device orientation
uint16 position_source # Source for position


"""
  # Pseudo-constants
  COVARIANCE_TYPE_UNKNOWN = 0
  COVARIANCE_TYPE_APPROXIMATED = 1
  COVARIANCE_TYPE_DIAGONAL_KNOWN = 2
  COVARIANCE_TYPE_KNOWN = 3

  __slots__ = ['header','status','latitude','longitude','altitude','track','speed','climb','pitch','roll','dip','time','gdop','pdop','hdop','vdop','tdop','err','err_horz','err_vert','err_track','err_speed','err_climb','err_time','err_pitch','err_roll','err_dip','position_covariance','position_covariance_type','lastRawData','rmc1UTCTime','rmc2STatus','rmc3Latitude','rmc4LatNorS','rmc5Longitude','rmc6LongEorW','rmc7SpeedOverGroundInKnots','rmc8TrackMadeGoodDegreeTrue','rmc9Date','rmc10MagneticVariationDegrees','rmc11MagnetEorW','rmc12FAAModeIndicator','gga1UTC','gga2Latitude','gga3LatNorS','gga4Longitude','gga5LongEorW','gga6GPSQuality','gga6GPSQualityStatus','gga7NumberOfSatellites','gga8HorizontalDilutionOfPrescision','gga9AntennaAltitudeAboveBelowMeanSeaLevel','gga10UnitsOfAntennaAltitude_inMeters','gga11GeoidalSeparation','gga12UnitsOfGeoidalSeperation','gga13AgeOfDifferentialGPSData','gga14DifferentialReferenceStationID','gsa1SelectionMode','gsa2Mode','gsa3ID1','gsa4ID2','gsa5ID3','gsa6ID4','gsa7ID5','gsa8ID6','gsa9ID7','gsa10ID8','gsa11ID9','gsa12ID10','gsa13ID11','gsa14ID12','gsa15PDOP','gsa16HDOP','gsa17VDOP','gsvAdet','gsv1NumberOfGSV','gsv2NumberOfMessage','gsv3NumberOfStallitesInView','gsv4SatellitePRNNumber','gsv5ElevationDegrees','gsv6AzimuthIndegries','gsv7SRNin_dB','gsv8MoreSatelliteInfoQuadruples']
  _slot_types = ['std_msgs/Header','gps_node/GPSStatus','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64[9]','uint8','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','string','int8','string','string','string','string','string','string','string','string']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,status,latitude,longitude,altitude,track,speed,climb,pitch,roll,dip,time,gdop,pdop,hdop,vdop,tdop,err,err_horz,err_vert,err_track,err_speed,err_climb,err_time,err_pitch,err_roll,err_dip,position_covariance,position_covariance_type,lastRawData,rmc1UTCTime,rmc2STatus,rmc3Latitude,rmc4LatNorS,rmc5Longitude,rmc6LongEorW,rmc7SpeedOverGroundInKnots,rmc8TrackMadeGoodDegreeTrue,rmc9Date,rmc10MagneticVariationDegrees,rmc11MagnetEorW,rmc12FAAModeIndicator,gga1UTC,gga2Latitude,gga3LatNorS,gga4Longitude,gga5LongEorW,gga6GPSQuality,gga6GPSQualityStatus,gga7NumberOfSatellites,gga8HorizontalDilutionOfPrescision,gga9AntennaAltitudeAboveBelowMeanSeaLevel,gga10UnitsOfAntennaAltitude_inMeters,gga11GeoidalSeparation,gga12UnitsOfGeoidalSeperation,gga13AgeOfDifferentialGPSData,gga14DifferentialReferenceStationID,gsa1SelectionMode,gsa2Mode,gsa3ID1,gsa4ID2,gsa5ID3,gsa6ID4,gsa7ID5,gsa8ID6,gsa9ID7,gsa10ID8,gsa11ID9,gsa12ID10,gsa13ID11,gsa14ID12,gsa15PDOP,gsa16HDOP,gsa17VDOP,gsvAdet,gsv1NumberOfGSV,gsv2NumberOfMessage,gsv3NumberOfStallitesInView,gsv4SatellitePRNNumber,gsv5ElevationDegrees,gsv6AzimuthIndegries,gsv7SRNin_dB,gsv8MoreSatelliteInfoQuadruples

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(GPSFix, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.status is None:
        self.status = gps_node.msg.GPSStatus()
      if self.latitude is None:
        self.latitude = 0.
      if self.longitude is None:
        self.longitude = 0.
      if self.altitude is None:
        self.altitude = 0.
      if self.track is None:
        self.track = 0.
      if self.speed is None:
        self.speed = 0.
      if self.climb is None:
        self.climb = 0.
      if self.pitch is None:
        self.pitch = 0.
      if self.roll is None:
        self.roll = 0.
      if self.dip is None:
        self.dip = 0.
      if self.time is None:
        self.time = 0.
      if self.gdop is None:
        self.gdop = 0.
      if self.pdop is None:
        self.pdop = 0.
      if self.hdop is None:
        self.hdop = 0.
      if self.vdop is None:
        self.vdop = 0.
      if self.tdop is None:
        self.tdop = 0.
      if self.err is None:
        self.err = 0.
      if self.err_horz is None:
        self.err_horz = 0.
      if self.err_vert is None:
        self.err_vert = 0.
      if self.err_track is None:
        self.err_track = 0.
      if self.err_speed is None:
        self.err_speed = 0.
      if self.err_climb is None:
        self.err_climb = 0.
      if self.err_time is None:
        self.err_time = 0.
      if self.err_pitch is None:
        self.err_pitch = 0.
      if self.err_roll is None:
        self.err_roll = 0.
      if self.err_dip is None:
        self.err_dip = 0.
      if self.position_covariance is None:
        self.position_covariance = [0.,0.,0.,0.,0.,0.,0.,0.,0.]
      if self.position_covariance_type is None:
        self.position_covariance_type = 0
      if self.lastRawData is None:
        self.lastRawData = ''
      if self.rmc1UTCTime is None:
        self.rmc1UTCTime = ''
      if self.rmc2STatus is None:
        self.rmc2STatus = ''
      if self.rmc3Latitude is None:
        self.rmc3Latitude = ''
      if self.rmc4LatNorS is None:
        self.rmc4LatNorS = ''
      if self.rmc5Longitude is None:
        self.rmc5Longitude = ''
      if self.rmc6LongEorW is None:
        self.rmc6LongEorW = ''
      if self.rmc7SpeedOverGroundInKnots is None:
        self.rmc7SpeedOverGroundInKnots = ''
      if self.rmc8TrackMadeGoodDegreeTrue is None:
        self.rmc8TrackMadeGoodDegreeTrue = ''
      if self.rmc9Date is None:
        self.rmc9Date = ''
      if self.rmc10MagneticVariationDegrees is None:
        self.rmc10MagneticVariationDegrees = ''
      if self.rmc11MagnetEorW is None:
        self.rmc11MagnetEorW = ''
      if self.rmc12FAAModeIndicator is None:
        self.rmc12FAAModeIndicator = ''
      if self.gga1UTC is None:
        self.gga1UTC = ''
      if self.gga2Latitude is None:
        self.gga2Latitude = ''
      if self.gga3LatNorS is None:
        self.gga3LatNorS = ''
      if self.gga4Longitude is None:
        self.gga4Longitude = ''
      if self.gga5LongEorW is None:
        self.gga5LongEorW = ''
      if self.gga6GPSQuality is None:
        self.gga6GPSQuality = ''
      if self.gga6GPSQualityStatus is None:
        self.gga6GPSQualityStatus = ''
      if self.gga7NumberOfSatellites is None:
        self.gga7NumberOfSatellites = ''
      if self.gga8HorizontalDilutionOfPrescision is None:
        self.gga8HorizontalDilutionOfPrescision = ''
      if self.gga9AntennaAltitudeAboveBelowMeanSeaLevel is None:
        self.gga9AntennaAltitudeAboveBelowMeanSeaLevel = ''
      if self.gga10UnitsOfAntennaAltitude_inMeters is None:
        self.gga10UnitsOfAntennaAltitude_inMeters = ''
      if self.gga11GeoidalSeparation is None:
        self.gga11GeoidalSeparation = ''
      if self.gga12UnitsOfGeoidalSeperation is None:
        self.gga12UnitsOfGeoidalSeperation = ''
      if self.gga13AgeOfDifferentialGPSData is None:
        self.gga13AgeOfDifferentialGPSData = ''
      if self.gga14DifferentialReferenceStationID is None:
        self.gga14DifferentialReferenceStationID = ''
      if self.gsa1SelectionMode is None:
        self.gsa1SelectionMode = ''
      if self.gsa2Mode is None:
        self.gsa2Mode = ''
      if self.gsa3ID1 is None:
        self.gsa3ID1 = ''
      if self.gsa4ID2 is None:
        self.gsa4ID2 = ''
      if self.gsa5ID3 is None:
        self.gsa5ID3 = ''
      if self.gsa6ID4 is None:
        self.gsa6ID4 = ''
      if self.gsa7ID5 is None:
        self.gsa7ID5 = ''
      if self.gsa8ID6 is None:
        self.gsa8ID6 = ''
      if self.gsa9ID7 is None:
        self.gsa9ID7 = ''
      if self.gsa10ID8 is None:
        self.gsa10ID8 = ''
      if self.gsa11ID9 is None:
        self.gsa11ID9 = ''
      if self.gsa12ID10 is None:
        self.gsa12ID10 = ''
      if self.gsa13ID11 is None:
        self.gsa13ID11 = ''
      if self.gsa14ID12 is None:
        self.gsa14ID12 = ''
      if self.gsa15PDOP is None:
        self.gsa15PDOP = ''
      if self.gsa16HDOP is None:
        self.gsa16HDOP = ''
      if self.gsa17VDOP is None:
        self.gsa17VDOP = ''
      if self.gsvAdet is None:
        self.gsvAdet = 0
      if self.gsv1NumberOfGSV is None:
        self.gsv1NumberOfGSV = ''
      if self.gsv2NumberOfMessage is None:
        self.gsv2NumberOfMessage = ''
      if self.gsv3NumberOfStallitesInView is None:
        self.gsv3NumberOfStallitesInView = ''
      if self.gsv4SatellitePRNNumber is None:
        self.gsv4SatellitePRNNumber = ''
      if self.gsv5ElevationDegrees is None:
        self.gsv5ElevationDegrees = ''
      if self.gsv6AzimuthIndegries is None:
        self.gsv6AzimuthIndegries = ''
      if self.gsv7SRNin_dB is None:
        self.gsv7SRNin_dB = ''
      if self.gsv8MoreSatelliteInfoQuadruples is None:
        self.gsv8MoreSatelliteInfoQuadruples = ''
    else:
      self.header = std_msgs.msg.Header()
      self.status = gps_node.msg.GPSStatus()
      self.latitude = 0.
      self.longitude = 0.
      self.altitude = 0.
      self.track = 0.
      self.speed = 0.
      self.climb = 0.
      self.pitch = 0.
      self.roll = 0.
      self.dip = 0.
      self.time = 0.
      self.gdop = 0.
      self.pdop = 0.
      self.hdop = 0.
      self.vdop = 0.
      self.tdop = 0.
      self.err = 0.
      self.err_horz = 0.
      self.err_vert = 0.
      self.err_track = 0.
      self.err_speed = 0.
      self.err_climb = 0.
      self.err_time = 0.
      self.err_pitch = 0.
      self.err_roll = 0.
      self.err_dip = 0.
      self.position_covariance = [0.,0.,0.,0.,0.,0.,0.,0.,0.]
      self.position_covariance_type = 0
      self.lastRawData = ''
      self.rmc1UTCTime = ''
      self.rmc2STatus = ''
      self.rmc3Latitude = ''
      self.rmc4LatNorS = ''
      self.rmc5Longitude = ''
      self.rmc6LongEorW = ''
      self.rmc7SpeedOverGroundInKnots = ''
      self.rmc8TrackMadeGoodDegreeTrue = ''
      self.rmc9Date = ''
      self.rmc10MagneticVariationDegrees = ''
      self.rmc11MagnetEorW = ''
      self.rmc12FAAModeIndicator = ''
      self.gga1UTC = ''
      self.gga2Latitude = ''
      self.gga3LatNorS = ''
      self.gga4Longitude = ''
      self.gga5LongEorW = ''
      self.gga6GPSQuality = ''
      self.gga6GPSQualityStatus = ''
      self.gga7NumberOfSatellites = ''
      self.gga8HorizontalDilutionOfPrescision = ''
      self.gga9AntennaAltitudeAboveBelowMeanSeaLevel = ''
      self.gga10UnitsOfAntennaAltitude_inMeters = ''
      self.gga11GeoidalSeparation = ''
      self.gga12UnitsOfGeoidalSeperation = ''
      self.gga13AgeOfDifferentialGPSData = ''
      self.gga14DifferentialReferenceStationID = ''
      self.gsa1SelectionMode = ''
      self.gsa2Mode = ''
      self.gsa3ID1 = ''
      self.gsa4ID2 = ''
      self.gsa5ID3 = ''
      self.gsa6ID4 = ''
      self.gsa7ID5 = ''
      self.gsa8ID6 = ''
      self.gsa9ID7 = ''
      self.gsa10ID8 = ''
      self.gsa11ID9 = ''
      self.gsa12ID10 = ''
      self.gsa13ID11 = ''
      self.gsa14ID12 = ''
      self.gsa15PDOP = ''
      self.gsa16HDOP = ''
      self.gsa17VDOP = ''
      self.gsvAdet = 0
      self.gsv1NumberOfGSV = ''
      self.gsv2NumberOfMessage = ''
      self.gsv3NumberOfStallitesInView = ''
      self.gsv4SatellitePRNNumber = ''
      self.gsv5ElevationDegrees = ''
      self.gsv6AzimuthIndegries = ''
      self.gsv7SRNin_dB = ''
      self.gsv8MoreSatelliteInfoQuadruples = ''

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_3I.pack(_x.status.header.seq, _x.status.header.stamp.secs, _x.status.header.stamp.nsecs))
      _x = self.status.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_H.pack(self.status.satellites_used))
      length = len(self.status.satellite_used_prn)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.status.satellite_used_prn))
      buff.write(_struct_H.pack(self.status.satellites_visible))
      length = len(self.status.satellite_visible_prn)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.status.satellite_visible_prn))
      length = len(self.status.satellite_visible_z)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.status.satellite_visible_z))
      length = len(self.status.satellite_visible_azimuth)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.status.satellite_visible_azimuth))
      length = len(self.status.satellite_visible_snr)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.pack(pattern, *self.status.satellite_visible_snr))
      _x = self
      buff.write(_struct_h3H25d.pack(_x.status.status, _x.status.motion_source, _x.status.orientation_source, _x.status.position_source, _x.latitude, _x.longitude, _x.altitude, _x.track, _x.speed, _x.climb, _x.pitch, _x.roll, _x.dip, _x.time, _x.gdop, _x.pdop, _x.hdop, _x.vdop, _x.tdop, _x.err, _x.err_horz, _x.err_vert, _x.err_track, _x.err_speed, _x.err_climb, _x.err_time, _x.err_pitch, _x.err_roll, _x.err_dip))
      buff.write(_struct_9d.pack(*self.position_covariance))
      buff.write(_struct_B.pack(self.position_covariance_type))
      _x = self.lastRawData
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc1UTCTime
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc2STatus
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc3Latitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc4LatNorS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc5Longitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc6LongEorW
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc7SpeedOverGroundInKnots
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc8TrackMadeGoodDegreeTrue
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc9Date
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc10MagneticVariationDegrees
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc11MagnetEorW
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc12FAAModeIndicator
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga1UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga2Latitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga3LatNorS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga4Longitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga5LongEorW
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga6GPSQuality
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga6GPSQualityStatus
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga7NumberOfSatellites
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga8HorizontalDilutionOfPrescision
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga9AntennaAltitudeAboveBelowMeanSeaLevel
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga10UnitsOfAntennaAltitude_inMeters
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga11GeoidalSeparation
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga12UnitsOfGeoidalSeperation
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga13AgeOfDifferentialGPSData
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga14DifferentialReferenceStationID
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa1SelectionMode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa2Mode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa3ID1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa4ID2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa5ID3
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa6ID4
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa7ID5
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa8ID6
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa9ID7
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa10ID8
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa11ID9
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa12ID10
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa13ID11
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa14ID12
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa15PDOP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa16HDOP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa17VDOP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_b.pack(self.gsvAdet))
      _x = self.gsv1NumberOfGSV
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv2NumberOfMessage
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv3NumberOfStallitesInView
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv4SatellitePRNNumber
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv5ElevationDegrees
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv6AzimuthIndegries
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv7SRNin_dB
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv8MoreSatelliteInfoQuadruples
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.status is None:
        self.status = gps_node.msg.GPSStatus()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.status.header.seq, _x.status.header.stamp.secs, _x.status.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.status.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.status.header.frame_id = str[start:end]
      start = end
      end += 2
      (self.status.satellites_used,) = _struct_H.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_used_prn = struct.unpack(pattern, str[start:end])
      start = end
      end += 2
      (self.status.satellites_visible,) = _struct_H.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_prn = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_z = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_azimuth = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_snr = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 208
      (_x.status.status, _x.status.motion_source, _x.status.orientation_source, _x.status.position_source, _x.latitude, _x.longitude, _x.altitude, _x.track, _x.speed, _x.climb, _x.pitch, _x.roll, _x.dip, _x.time, _x.gdop, _x.pdop, _x.hdop, _x.vdop, _x.tdop, _x.err, _x.err_horz, _x.err_vert, _x.err_track, _x.err_speed, _x.err_climb, _x.err_time, _x.err_pitch, _x.err_roll, _x.err_dip,) = _struct_h3H25d.unpack(str[start:end])
      start = end
      end += 72
      self.position_covariance = _struct_9d.unpack(str[start:end])
      start = end
      end += 1
      (self.position_covariance_type,) = _struct_B.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.lastRawData = str[start:end].decode('utf-8')
      else:
        self.lastRawData = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc1UTCTime = str[start:end].decode('utf-8')
      else:
        self.rmc1UTCTime = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc2STatus = str[start:end].decode('utf-8')
      else:
        self.rmc2STatus = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc3Latitude = str[start:end].decode('utf-8')
      else:
        self.rmc3Latitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc4LatNorS = str[start:end].decode('utf-8')
      else:
        self.rmc4LatNorS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc5Longitude = str[start:end].decode('utf-8')
      else:
        self.rmc5Longitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc6LongEorW = str[start:end].decode('utf-8')
      else:
        self.rmc6LongEorW = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc7SpeedOverGroundInKnots = str[start:end].decode('utf-8')
      else:
        self.rmc7SpeedOverGroundInKnots = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc8TrackMadeGoodDegreeTrue = str[start:end].decode('utf-8')
      else:
        self.rmc8TrackMadeGoodDegreeTrue = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc9Date = str[start:end].decode('utf-8')
      else:
        self.rmc9Date = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc10MagneticVariationDegrees = str[start:end].decode('utf-8')
      else:
        self.rmc10MagneticVariationDegrees = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc11MagnetEorW = str[start:end].decode('utf-8')
      else:
        self.rmc11MagnetEorW = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc12FAAModeIndicator = str[start:end].decode('utf-8')
      else:
        self.rmc12FAAModeIndicator = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga1UTC = str[start:end].decode('utf-8')
      else:
        self.gga1UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga2Latitude = str[start:end].decode('utf-8')
      else:
        self.gga2Latitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga3LatNorS = str[start:end].decode('utf-8')
      else:
        self.gga3LatNorS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga4Longitude = str[start:end].decode('utf-8')
      else:
        self.gga4Longitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga5LongEorW = str[start:end].decode('utf-8')
      else:
        self.gga5LongEorW = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga6GPSQuality = str[start:end].decode('utf-8')
      else:
        self.gga6GPSQuality = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga6GPSQualityStatus = str[start:end].decode('utf-8')
      else:
        self.gga6GPSQualityStatus = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga7NumberOfSatellites = str[start:end].decode('utf-8')
      else:
        self.gga7NumberOfSatellites = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga8HorizontalDilutionOfPrescision = str[start:end].decode('utf-8')
      else:
        self.gga8HorizontalDilutionOfPrescision = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga9AntennaAltitudeAboveBelowMeanSeaLevel = str[start:end].decode('utf-8')
      else:
        self.gga9AntennaAltitudeAboveBelowMeanSeaLevel = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga10UnitsOfAntennaAltitude_inMeters = str[start:end].decode('utf-8')
      else:
        self.gga10UnitsOfAntennaAltitude_inMeters = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga11GeoidalSeparation = str[start:end].decode('utf-8')
      else:
        self.gga11GeoidalSeparation = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga12UnitsOfGeoidalSeperation = str[start:end].decode('utf-8')
      else:
        self.gga12UnitsOfGeoidalSeperation = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga13AgeOfDifferentialGPSData = str[start:end].decode('utf-8')
      else:
        self.gga13AgeOfDifferentialGPSData = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga14DifferentialReferenceStationID = str[start:end].decode('utf-8')
      else:
        self.gga14DifferentialReferenceStationID = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa1SelectionMode = str[start:end].decode('utf-8')
      else:
        self.gsa1SelectionMode = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa2Mode = str[start:end].decode('utf-8')
      else:
        self.gsa2Mode = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa3ID1 = str[start:end].decode('utf-8')
      else:
        self.gsa3ID1 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa4ID2 = str[start:end].decode('utf-8')
      else:
        self.gsa4ID2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa5ID3 = str[start:end].decode('utf-8')
      else:
        self.gsa5ID3 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa6ID4 = str[start:end].decode('utf-8')
      else:
        self.gsa6ID4 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa7ID5 = str[start:end].decode('utf-8')
      else:
        self.gsa7ID5 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa8ID6 = str[start:end].decode('utf-8')
      else:
        self.gsa8ID6 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa9ID7 = str[start:end].decode('utf-8')
      else:
        self.gsa9ID7 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa10ID8 = str[start:end].decode('utf-8')
      else:
        self.gsa10ID8 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa11ID9 = str[start:end].decode('utf-8')
      else:
        self.gsa11ID9 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa12ID10 = str[start:end].decode('utf-8')
      else:
        self.gsa12ID10 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa13ID11 = str[start:end].decode('utf-8')
      else:
        self.gsa13ID11 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa14ID12 = str[start:end].decode('utf-8')
      else:
        self.gsa14ID12 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa15PDOP = str[start:end].decode('utf-8')
      else:
        self.gsa15PDOP = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa16HDOP = str[start:end].decode('utf-8')
      else:
        self.gsa16HDOP = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa17VDOP = str[start:end].decode('utf-8')
      else:
        self.gsa17VDOP = str[start:end]
      start = end
      end += 1
      (self.gsvAdet,) = _struct_b.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv1NumberOfGSV = str[start:end].decode('utf-8')
      else:
        self.gsv1NumberOfGSV = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv2NumberOfMessage = str[start:end].decode('utf-8')
      else:
        self.gsv2NumberOfMessage = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv3NumberOfStallitesInView = str[start:end].decode('utf-8')
      else:
        self.gsv3NumberOfStallitesInView = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv4SatellitePRNNumber = str[start:end].decode('utf-8')
      else:
        self.gsv4SatellitePRNNumber = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv5ElevationDegrees = str[start:end].decode('utf-8')
      else:
        self.gsv5ElevationDegrees = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv6AzimuthIndegries = str[start:end].decode('utf-8')
      else:
        self.gsv6AzimuthIndegries = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv7SRNin_dB = str[start:end].decode('utf-8')
      else:
        self.gsv7SRNin_dB = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv8MoreSatelliteInfoQuadruples = str[start:end].decode('utf-8')
      else:
        self.gsv8MoreSatelliteInfoQuadruples = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_3I.pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_struct_3I.pack(_x.status.header.seq, _x.status.header.stamp.secs, _x.status.header.stamp.nsecs))
      _x = self.status.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_H.pack(self.status.satellites_used))
      length = len(self.status.satellite_used_prn)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.status.satellite_used_prn.tostring())
      buff.write(_struct_H.pack(self.status.satellites_visible))
      length = len(self.status.satellite_visible_prn)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.status.satellite_visible_prn.tostring())
      length = len(self.status.satellite_visible_z)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.status.satellite_visible_z.tostring())
      length = len(self.status.satellite_visible_azimuth)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.status.satellite_visible_azimuth.tostring())
      length = len(self.status.satellite_visible_snr)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.status.satellite_visible_snr.tostring())
      _x = self
      buff.write(_struct_h3H25d.pack(_x.status.status, _x.status.motion_source, _x.status.orientation_source, _x.status.position_source, _x.latitude, _x.longitude, _x.altitude, _x.track, _x.speed, _x.climb, _x.pitch, _x.roll, _x.dip, _x.time, _x.gdop, _x.pdop, _x.hdop, _x.vdop, _x.tdop, _x.err, _x.err_horz, _x.err_vert, _x.err_track, _x.err_speed, _x.err_climb, _x.err_time, _x.err_pitch, _x.err_roll, _x.err_dip))
      buff.write(self.position_covariance.tostring())
      buff.write(_struct_B.pack(self.position_covariance_type))
      _x = self.lastRawData
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc1UTCTime
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc2STatus
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc3Latitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc4LatNorS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc5Longitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc6LongEorW
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc7SpeedOverGroundInKnots
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc8TrackMadeGoodDegreeTrue
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc9Date
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc10MagneticVariationDegrees
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc11MagnetEorW
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.rmc12FAAModeIndicator
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga1UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga2Latitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga3LatNorS
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga4Longitude
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga5LongEorW
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga6GPSQuality
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga6GPSQualityStatus
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga7NumberOfSatellites
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga8HorizontalDilutionOfPrescision
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga9AntennaAltitudeAboveBelowMeanSeaLevel
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga10UnitsOfAntennaAltitude_inMeters
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga11GeoidalSeparation
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga12UnitsOfGeoidalSeperation
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga13AgeOfDifferentialGPSData
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gga14DifferentialReferenceStationID
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa1SelectionMode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa2Mode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa3ID1
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa4ID2
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa5ID3
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa6ID4
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa7ID5
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa8ID6
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa9ID7
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa10ID8
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa11ID9
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa12ID10
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa13ID11
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa14ID12
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa15PDOP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa16HDOP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsa17VDOP
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      buff.write(_struct_b.pack(self.gsvAdet))
      _x = self.gsv1NumberOfGSV
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv2NumberOfMessage
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv3NumberOfStallitesInView
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv4SatellitePRNNumber
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv5ElevationDegrees
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv6AzimuthIndegries
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv7SRNin_dB
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.gsv8MoreSatelliteInfoQuadruples
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.status is None:
        self.status = gps_node.msg.GPSStatus()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.status.header.seq, _x.status.header.stamp.secs, _x.status.header.stamp.nsecs,) = _struct_3I.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.status.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.status.header.frame_id = str[start:end]
      start = end
      end += 2
      (self.status.satellites_used,) = _struct_H.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_used_prn = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 2
      (self.status.satellites_visible,) = _struct_H.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_prn = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_z = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_azimuth = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      end += struct.calcsize(pattern)
      self.status.satellite_visible_snr = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      _x = self
      start = end
      end += 208
      (_x.status.status, _x.status.motion_source, _x.status.orientation_source, _x.status.position_source, _x.latitude, _x.longitude, _x.altitude, _x.track, _x.speed, _x.climb, _x.pitch, _x.roll, _x.dip, _x.time, _x.gdop, _x.pdop, _x.hdop, _x.vdop, _x.tdop, _x.err, _x.err_horz, _x.err_vert, _x.err_track, _x.err_speed, _x.err_climb, _x.err_time, _x.err_pitch, _x.err_roll, _x.err_dip,) = _struct_h3H25d.unpack(str[start:end])
      start = end
      end += 72
      self.position_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      start = end
      end += 1
      (self.position_covariance_type,) = _struct_B.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.lastRawData = str[start:end].decode('utf-8')
      else:
        self.lastRawData = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc1UTCTime = str[start:end].decode('utf-8')
      else:
        self.rmc1UTCTime = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc2STatus = str[start:end].decode('utf-8')
      else:
        self.rmc2STatus = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc3Latitude = str[start:end].decode('utf-8')
      else:
        self.rmc3Latitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc4LatNorS = str[start:end].decode('utf-8')
      else:
        self.rmc4LatNorS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc5Longitude = str[start:end].decode('utf-8')
      else:
        self.rmc5Longitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc6LongEorW = str[start:end].decode('utf-8')
      else:
        self.rmc6LongEorW = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc7SpeedOverGroundInKnots = str[start:end].decode('utf-8')
      else:
        self.rmc7SpeedOverGroundInKnots = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc8TrackMadeGoodDegreeTrue = str[start:end].decode('utf-8')
      else:
        self.rmc8TrackMadeGoodDegreeTrue = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc9Date = str[start:end].decode('utf-8')
      else:
        self.rmc9Date = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc10MagneticVariationDegrees = str[start:end].decode('utf-8')
      else:
        self.rmc10MagneticVariationDegrees = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc11MagnetEorW = str[start:end].decode('utf-8')
      else:
        self.rmc11MagnetEorW = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.rmc12FAAModeIndicator = str[start:end].decode('utf-8')
      else:
        self.rmc12FAAModeIndicator = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga1UTC = str[start:end].decode('utf-8')
      else:
        self.gga1UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga2Latitude = str[start:end].decode('utf-8')
      else:
        self.gga2Latitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga3LatNorS = str[start:end].decode('utf-8')
      else:
        self.gga3LatNorS = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga4Longitude = str[start:end].decode('utf-8')
      else:
        self.gga4Longitude = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga5LongEorW = str[start:end].decode('utf-8')
      else:
        self.gga5LongEorW = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga6GPSQuality = str[start:end].decode('utf-8')
      else:
        self.gga6GPSQuality = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga6GPSQualityStatus = str[start:end].decode('utf-8')
      else:
        self.gga6GPSQualityStatus = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga7NumberOfSatellites = str[start:end].decode('utf-8')
      else:
        self.gga7NumberOfSatellites = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga8HorizontalDilutionOfPrescision = str[start:end].decode('utf-8')
      else:
        self.gga8HorizontalDilutionOfPrescision = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga9AntennaAltitudeAboveBelowMeanSeaLevel = str[start:end].decode('utf-8')
      else:
        self.gga9AntennaAltitudeAboveBelowMeanSeaLevel = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga10UnitsOfAntennaAltitude_inMeters = str[start:end].decode('utf-8')
      else:
        self.gga10UnitsOfAntennaAltitude_inMeters = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga11GeoidalSeparation = str[start:end].decode('utf-8')
      else:
        self.gga11GeoidalSeparation = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga12UnitsOfGeoidalSeperation = str[start:end].decode('utf-8')
      else:
        self.gga12UnitsOfGeoidalSeperation = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga13AgeOfDifferentialGPSData = str[start:end].decode('utf-8')
      else:
        self.gga13AgeOfDifferentialGPSData = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gga14DifferentialReferenceStationID = str[start:end].decode('utf-8')
      else:
        self.gga14DifferentialReferenceStationID = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa1SelectionMode = str[start:end].decode('utf-8')
      else:
        self.gsa1SelectionMode = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa2Mode = str[start:end].decode('utf-8')
      else:
        self.gsa2Mode = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa3ID1 = str[start:end].decode('utf-8')
      else:
        self.gsa3ID1 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa4ID2 = str[start:end].decode('utf-8')
      else:
        self.gsa4ID2 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa5ID3 = str[start:end].decode('utf-8')
      else:
        self.gsa5ID3 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa6ID4 = str[start:end].decode('utf-8')
      else:
        self.gsa6ID4 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa7ID5 = str[start:end].decode('utf-8')
      else:
        self.gsa7ID5 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa8ID6 = str[start:end].decode('utf-8')
      else:
        self.gsa8ID6 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa9ID7 = str[start:end].decode('utf-8')
      else:
        self.gsa9ID7 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa10ID8 = str[start:end].decode('utf-8')
      else:
        self.gsa10ID8 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa11ID9 = str[start:end].decode('utf-8')
      else:
        self.gsa11ID9 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa12ID10 = str[start:end].decode('utf-8')
      else:
        self.gsa12ID10 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa13ID11 = str[start:end].decode('utf-8')
      else:
        self.gsa13ID11 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa14ID12 = str[start:end].decode('utf-8')
      else:
        self.gsa14ID12 = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa15PDOP = str[start:end].decode('utf-8')
      else:
        self.gsa15PDOP = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa16HDOP = str[start:end].decode('utf-8')
      else:
        self.gsa16HDOP = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsa17VDOP = str[start:end].decode('utf-8')
      else:
        self.gsa17VDOP = str[start:end]
      start = end
      end += 1
      (self.gsvAdet,) = _struct_b.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv1NumberOfGSV = str[start:end].decode('utf-8')
      else:
        self.gsv1NumberOfGSV = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv2NumberOfMessage = str[start:end].decode('utf-8')
      else:
        self.gsv2NumberOfMessage = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv3NumberOfStallitesInView = str[start:end].decode('utf-8')
      else:
        self.gsv3NumberOfStallitesInView = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv4SatellitePRNNumber = str[start:end].decode('utf-8')
      else:
        self.gsv4SatellitePRNNumber = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv5ElevationDegrees = str[start:end].decode('utf-8')
      else:
        self.gsv5ElevationDegrees = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv6AzimuthIndegries = str[start:end].decode('utf-8')
      else:
        self.gsv6AzimuthIndegries = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv7SRNin_dB = str[start:end].decode('utf-8')
      else:
        self.gsv7SRNin_dB = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.gsv8MoreSatelliteInfoQuadruples = str[start:end].decode('utf-8')
      else:
        self.gsv8MoreSatelliteInfoQuadruples = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_B = struct.Struct("<B")
_struct_h3H25d = struct.Struct("<h3H25d")
_struct_H = struct.Struct("<H")
_struct_9d = struct.Struct("<9d")
_struct_3I = struct.Struct("<3I")
_struct_b = struct.Struct("<b")
